{"comment":"Sstan","footnote":"","findings":[{"severity":"High","title":"Uninitialized storage variables","description":"A storage variable that is declared but not initialized will have a default value of zero (or the equivalent, such as an empty array for array types or zero-address for address types). Failing to initialize a storage variable can pose risks if the contract logic assumes that the variable has been explicitly set to a particular value.","gasSavings":null,"category":null,"instances":[{"content":["18:    string public name = \"Wrapped Ether\";\n"],"loc":["./src/WETH9.sol"]},{"content":["19:    string public symbol = \"WETH\";\n"],"loc":["./src/WETH9.sol"]},{"content":["20:    uint8 public decimals = 18;\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"Low","title":"Use a locked pragma version instead of a floating pragma version","description":"\"\"\n        Floating pragma is a vulnerability in smart contract code that can cause unexpected behavior by allowing the compiler to use a specified range of versions. \\n This can lead to issues such as using an older compiler version with known vulnerabilities, using a newer compiler version with undiscovered vulnerabilities, inconsistency across files using different versions, or unpredictable behavior because the compiler can use any version within the specified range. It is recommended to use a locked pragma version in order to avoid these potential vulnerabilities. In some cases it may be acceptable to use a floating pragma, such as when a contract is intended for consumption by other developers and needs to be compatible with a range of compiler versions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Bad\n\n        ```js\n            pragma solidity ^0.8.0;\n        ```\n\n        #### Good\n\n        ```js\n            pragma solidity 0.8.15;\n        ```\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["15:pragma solidity ^0.8.13;\n"],"loc":["./src/WETH9.sol"]},{"content":["2:pragma solidity ^0.8.19;\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["1:pragma solidity ^0.8.19;\n"],"loc":["./src/FundMe/PriceConverter.sol"]}]},{"severity":"Low","title":"Unsafe ERC20 Operation","description":"\"\"\n        ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard. To account for this, either use OpenZeppelin's SafeERC20 library or wrap each operation in a require statement. \\n\n        > Additionally, ERC20's approve functions have a known race-condition vulnerability. To account for this, use OpenZeppelin's SafeERC20 library's `safeIncrease` or `safeDecrease` Allowance functions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Unsafe Transfer\n\n        ```js\n        IERC20(token).transfer(msg.sender, amount);\n        ```\n\n        #### OpenZeppelin SafeTransfer\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransfer(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe Transfer with require statement.\n\n        ```js\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n                \n        #### Unsafe TransferFrom\n\n        ```js\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        ```\n\n        #### OpenZeppelin SafeTransferFrom\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe TransferFrom with require statement.\n\n        ```js\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["42:        payable(msg.sender).transfer(wad);\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"NonCritical","title":"Private variables should contain a leading underscore","description":"Consider adding an underscore to the beginning of the variable name","gasSavings":null,"category":null,"instances":[{"content":["23:    address private immutable i_owner;\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"NonCritical","title":"Constructor should check that all parameters are not 0","description":"Consider adding a require statement to check that all parameters are not 0 in the constructor","gasSavings":null,"category":null,"instances":[{"content":["47:    constructor(address priceFeed) {\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"NonCritical","title":"This error has no parameters, the state of the contract when the revert occured will not be available","description":"Consider adding parameters to the error to provide more context when a transaction fails","gasSavings":null,"category":null,"instances":[{"content":["9:error FundMe__NotOwner();\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"NonCritical","title":"Function names should be in camelCase","description":"Ensure that function definitions are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]},{"content":["53:    function fund() public payable {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["60:    function withdraw() public onlyOwner {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["34:    function deposit() public payable {\n"],"loc":["./src/WETH9.sol"]},{"content":["39:    function withdraw(uint256 wad) public {\n"],"loc":["./src/WETH9.sol"]},{"content":["50:    function approve(address guy, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["56:    function transfer(address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"NonCritical","title":"Require/Revert statements should be consistent across the codebase","description":"Consider using require/revert statements consistently across the codebase","gasSavings":null,"category":null,"instances":[{"content":["23:    address private immutable i_owner;\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"NonCritical","title":"Constant and immutable variable names should be in SCREAMING_SNAKE_CASE","description":"Ensure that Constant and immutable variable names are declared using SCREAMING_SNAKE_CASE","gasSavings":null,"category":null,"instances":[{"content":["23:    address private immutable i_owner;\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"NonCritical","title":"Consider marking public function External","description":"If a public function is never called internally, it is best practice to mark it as external.","gasSavings":null,"category":null,"instances":[{"content":["98:    function getVersion() public view returns (uint256) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["106:    function getOwner() public view returns (address) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["72:    function cheaperWithdraw() public onlyOwner {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["102:    function getFunder(uint256 index) public view returns (address) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["60:    function withdraw() public onlyOwner {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["94:    function getAddressToAmountFunded(address fundingAddress) public view returns (uint256) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["53:    function fund() public payable {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["110:    function getPriceFeed() public view returns (AggregatorV3Interface) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["50:    function approve(address guy, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["39:    function withdraw(uint256 wad) public {\n"],"loc":["./src/WETH9.sol"]},{"content":["56:    function transfer(address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["46:    function totalSupply() public view returns (uint256) {\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"NonCritical","title":"Consider adding a message with require and revert statements","description":"Adding a message to accompany require statements will provide more context when a transaction fails.","gasSavings":null,"category":null,"instances":[{"content":["40:        require(balanceOf[msg.sender] >= wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["61:        require(balanceOf[src] >= wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["64:            require(allowance[src][msg.sender] >= wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["69:        require(success);\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["82:        require(success);\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"NonCritical","title":"Remove any unused functions","description":"Any functions not used should be removed as best practice.","gasSavings":null,"category":null,"instances":[{"content":["15:    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed) internal view returns (uint256) {\n"],"loc":["./src/FundMe/PriceConverter.sol"]}]},{"severity":"NonCritical","title":"Function parameters should be in camelCase","description":"Ensure that function parameters are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["39:    function withdraw(uint256 wad) public {\n"],"loc":["./src/WETH9.sol"]},{"content":["50:    function approve(address guy, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["50:    function approve(address guy, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["56:    function transfer(address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["56:    function transfer(address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["60:    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["60:    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["60:    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["7:        (, int256 answer,,,) = priceFeed.latestRoundData();\n"],"loc":["./src/FundMe/PriceConverter.sol"]},{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]},{"content":["68:        (bool success,) = i_owner.call{ value: address(this).balance }(\"\");\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["81:        (bool success,) = i_owner.call{ value: address(this).balance }(\"\");\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["102:    function getFunder(uint256 index) public view returns (address) {\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"NonCritical","title":"Consider explicitly naming mapping parameters","description":"Consider explicitly naming mapping parameters for readability","gasSavings":null,"category":null,"instances":[{"content":["25:    mapping(address => uint256) private s_addressToAmountFunded;\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["27:    mapping(address => uint256) public balanceOf;\n"],"loc":["./src/WETH9.sol"]},{"content":["28:    mapping(address => mapping(address => uint256)) public allowance;\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `constant` if they never change.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["20:    uint8 public decimals = 18;\n"],"loc":["./src/WETH9.sol"]},{"content":["19:    string public symbol = \"WETH\";\n"],"loc":["./src/WETH9.sol"]},{"content":["18:    string public name = \"Wrapped Ether\";\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `immutable` if they never change after contract initialization.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. \n - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["26:    AggregatorV3Interface private s_priceFeed;\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"Gas","title":"Consider marking constants as private","description":"\n Consider marking constant variables in storage as private to save gas (unless a constant variable should be easily accessible by another protocol or offchain logic). - Savings: ~22 \n","gasSavings":null,"category":null,"instances":[{"content":["22:    uint256 public constant MINIMUM_USD = 5 * 10 ** 18;\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"Gas","title":"`unchecked{++i}` instead of `i++` (or use assembly when applicable)","description":"\n Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas. - Savings: ~342 \n","gasSavings":null,"category":null,"instances":[{"content":["75:        for (uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["61:        for (uint256 funderIndex = 0; funderIndex < s_funders.length; funderIndex++) {\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"Gas","title":"Cache Storage Variables in Memory","description":"\n  - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["62:            address funder = s_funders[funderIndex];\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["65:        s_funders = new address[](0);\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["62:            address funder = s_funders[funderIndex];\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["65:        s_funders = new address[](0);\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["79:        s_funders = new address[](0);\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["79:        s_funders = new address[](0);\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["41:        balanceOf[msg.sender] -= wad;\n"],"loc":["./src/WETH9.sol"]},{"content":["64:            require(allowance[src][msg.sender] >= wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["65:            allowance[src][msg.sender] -= wad;\n"],"loc":["./src/WETH9.sol"]},{"content":["68:        balanceOf[src] -= wad;\n"],"loc":["./src/WETH9.sol"]},{"content":["69:        balanceOf[dst] += wad;\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"Gas","title":"Optimal Comparison","description":"\n When comparing integers, it is cheaper to use strict `>` & `<` operators over `>=` & `<=` operators, even if you must increment or decrement one of the operands. \n Note: before using this technique, it's important to consider whether incrementing/decrementing one of the operators could result in an over/underflow. This optimization is applicable when the optimizer is turned off. - Savings: ~3 \n","gasSavings":null,"category":null,"instances":[{"content":["54:        require(msg.value.getConversionRate(s_priceFeed) >= MINIMUM_USD, \"You need to spend more ETH!\");\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["40:        require(balanceOf[msg.sender] >= wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["61:        require(balanceOf[src] >= wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["64:            require(allowance[src][msg.sender] >= wad);\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"Gas","title":"Use custom errors instead of string error messages","description":"\n Using custom errors will save you gas, and can be used to provide more information about the error. - Savings: ~57 \n","gasSavings":null,"category":null,"instances":[{"content":["54:        require(msg.value.getConversionRate(s_priceFeed) >= MINIMUM_USD, \"You need to spend more ETH!\");\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"Gas","title":"Use assembly for math (add, sub, mul, div)","description":"\n Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow. - Savings: ~60 \n","gasSavings":null,"category":null,"instances":[{"content":["22:    uint256 public constant MINIMUM_USD = 5 * 10 ** 18;\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["9:        return uint256(answer * 10_000_000_000);\n"],"loc":["./src/FundMe/PriceConverter.sol"]},{"content":["17:        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1_000_000_000_000_000_000;\n"],"loc":["./src/FundMe/PriceConverter.sol"]},{"content":["17:        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1_000_000_000_000_000_000;\n"],"loc":["./src/FundMe/PriceConverter.sol"]}]},{"severity":"Gas","title":"Event is not properly indexed.","description":"\n When possible, always include a minimum of 3 indexed event topics to save gas - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["22:    event Approval(address indexed src, address indexed guy, uint256 wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["23:    event Transfer(address indexed src, address indexed dst, uint256 wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["24:    event Deposit(address indexed dst, uint256 wad);\n"],"loc":["./src/WETH9.sol"]},{"content":["25:    event Withdrawal(address indexed src, uint256 wad);\n"],"loc":["./src/WETH9.sol"]}]},{"severity":"Gas","title":"Mark functions as payable (with discretion)","description":"\n You can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether. - Savings: ~24 \n","gasSavings":null,"category":null,"instances":[{"content":["60:    function withdraw() public onlyOwner {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["72:    function cheaperWithdraw() public onlyOwner {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["94:    function getAddressToAmountFunded(address fundingAddress) public view returns (uint256) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["98:    function getVersion() public view returns (uint256) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["102:    function getFunder(uint256 index) public view returns (address) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["106:    function getOwner() public view returns (address) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["110:    function getPriceFeed() public view returns (AggregatorV3Interface) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["39:    function withdraw(uint256 wad) public {\n"],"loc":["./src/WETH9.sol"]},{"content":["46:    function totalSupply() public view returns (uint256) {\n"],"loc":["./src/WETH9.sol"]},{"content":["50:    function approve(address guy, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["56:    function transfer(address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["60:    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n"],"loc":["./src/WETH9.sol"]},{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]}]},{"severity":"Gas","title":"Use assembly when getting a contract's balance of ETH","description":"\n You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH. - Savings: ~15 \n","gasSavings":null,"category":null,"instances":[{"content":["47:        return address(this).balance;\n"],"loc":["./src/WETH9.sol"]},{"content":["68:        (bool success,) = i_owner.call{ value: address(this).balance }(\"\");\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["81:        (bool success,) = i_owner.call{ value: address(this).balance }(\"\");\n"],"loc":["./src/FundMe/FundMe.sol"]}]},{"severity":"Gas","title":"Cache array length during for loop definition.","description":"\n A typical for loop definition may look like: `for (uint256 i; i < arr.length; i++){}`. Instead of using `array.length`, cache the array length before the loop, and use the cached value to safe gas. This will avoid an `MLOAD` every loop for arrays stored in memory and an `SLOAD` for arrays stored in storage. This can have significant gas savings for arrays with a large length, especially if the array is stored in storage. - Savings: ~22 \n","gasSavings":null,"category":null,"instances":[{"content":["61:        for (uint256 funderIndex = 0; funderIndex < s_funders.length; funderIndex++) {\n"],"loc":["./src/FundMe/FundMe.sol"]},{"content":["75:        for (uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++) {\n"],"loc":["./src/FundMe/FundMe.sol"]}]}]}